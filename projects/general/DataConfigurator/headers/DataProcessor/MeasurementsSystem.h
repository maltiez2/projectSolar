#pragma once
#include <Eigen/Core>
#include <QtGlobal>
#include <QMap>
#include <QString>
#include <QSet>
#include <QJsonObject>
#include <QObject>

/**
 * Contains classes for storage, loading and saving units systems, and also for converting between units.
 */
namespace measurementsSystem
{
    const quint8 dimensionsSpaceDimesion = 4; // Size of basis in quantity dimensions space
    using Dimension = Eigen::Matrix<qint8, dimensionsSpaceDimesion, 1>; // Column vector in quantity dimensions space

    struct Value;

    class Quantity;
    class Unit;
    class UnitsSystem;
    class UnitsConverter;
    class DimensionsConverter;
    class ConfigurationFileManager;
    class measurementSystemManager;

    /**
     * Representation of physical quantity like 'length' or 'mass'.
     * There should be at most 256 quantities in units system.
     */
    class Quantity
    {
    public:
        QString symbol; // Short scientific notation like 'L' or 'T', should not repeat inside units system.
        QString title; // Short description like 'Length' or 'Time'
        Dimension dimension; // Vector of powers of basis quantities (vector in dimensions space)

        /**
         * Converts into json object for writing into file.
         * 
         * @return json object with format {"symbol":symbol,"title":title,"dimension":[0,1,0,0]}
         */
        QJsonObject toJson() const;
        /**
         * Converts json object with same to 'toJson()' format back into 'Quantity' class instance.
         * 
         * @param jsonObject format: {"symbol":symbol,"title":title,"dimension":[0,1,0,0]}
         * @return instance of 'Quantity' with data from 'jsonObject'
         */
        static Quantity fromJson(const QJsonObject& jsonObject);

        /**
         * Equivalence means that two quantities are interchangeable, which means equal dimensions.
         * 
         * @param quantity Quantity to compare with
         * @return true if equal
         */
        bool isEquivalentTo(const Quantity& quantity) const;
        /**
         * Look for 'isEquivalentTo' method documentation.
         * 
         * @param first
         * @param second
         * @return true if equal
         */
        static bool isEquivalent(const Quantity& first, const Quantity& second);

    private:
        /**
         * Converts 'dimension' field in given object into DImension class.
         * 
         * @param jsonObject should contain "dimension":[...]
         * @return instance of Dimension object
         */
        static Dimension getDimensionFormObject(const QJsonObject& jsonObject);
    };

    /**
     * Representation of physical unit of physical quantity.
     * There should be at most 256 units in units system.
     */
    class Unit
    {
    public:
        QString symbol; // Short scientific notation like 'm' or 'kg', should not repeat inside units system.
        QString title; // Short description like 'metre' or 'kilograms'
        quint8 quantityId; // Generated by UnitsSystem class, used in data files and configuration files for mapping to quantities
        qreal convertionRatioFromBaseUnits; // Multiplier used to convert from coherent unit (multiplier = 1) of the same quantity

        /**
         * Converts into json object for writing into file.
         * 
         * @return json object with format {"symbol":symbol,{"title":title},"quantity":quantityId,"convertionRatioFromBaseUnits":convertionRatioFromBaseUnits}
         */
        QJsonObject toJson() const;
        /**
         * Converts json object with same to 'toJson()' format back into 'Unit' class instance.
         *
         * @param jsonObject format: {"symbol":symbol,{"title":title},"quantity":quantityId,"convertionRatioFromBaseUnits":convertionRatioFromBaseUnits}
         * @return instance of 'Unit' with data from 'jsonObject'
         */
        static Unit fromJson(const QJsonObject& jsonObject);

        /**
         * Equivalence means that two units are interchangeable, which means equivalent quantities and equal conversion ratios.
         *
         * @param unit Unit to compare with
         * @param system UnitsSystem to look quantities in for comparison
         * @return true if equal
         */
        bool isEquivalentTo(const Unit& unit, const UnitsSystem& system) const;
        /**
         * Look for 'isEquivalentTo' method documentation.
         *
         * @param first
         * @param second
         * @param unitsSystem
         * @return true if equal
         */
        static bool isEquivalent(const Unit& first, const Unit& second, const UnitsSystem& system);
    };

    /**
     * Representation of physical units system.
     * Used for managing units and quantities: currently only adding new units and quantities, and converting to/from json format.
     * Units and quantities does not meant to be removed from system.
     * Use 'addBaseUnit' and 'addAdditionalUnits' for adding units and quantities.
     * It is better to add basis before derived quantities.
     */
    class UnitsSystem
    {
    public:
        QString symbol; // Short scientific notation like 'SI' or 'SGS', should not repeat inside file system, used as name of configuration file
        QString title; // Short description like 'International System of Units'
        QMap<quint8, Quantity> quantities; // Map from quantities ids to quantities themselves (id -> quantity)
        QMap<quint8, Unit> units; // Map from units ids to units themselves (id -> unit)

        QMap<QString, quint8> quantitiesBySymbol; // For searching by symbol (id -> symbol)
        QSet<quint8> baseQuantities; // Basis of units system (dimension vectors that form orthonormal basis, vectors look like [0,1,0,0])
        QSet<quint8> derivedQuantities; // Derived quantities with dimensions not from basis

        QMap<QString, quint8> unitsBySymbol; // For searching by symbol (id -> symbol)
        QSet<quint8> coherentUnits; // Units with converting ration equal to 1.0
        QSet<quint8> nonCoherentUnits; // Units with converting ration not equal to 1.0

        QMap<quint8, quint8> quantitiesByUnits; // Maps each unit to its quantity (unit id -> quantity id)
        QMap<quint8, quint8> coherentUnitsByQuantities; // Maps each quantity to one of its coherent unit (quantity id -> unit id)

        /**
         * Converts into json object for writing into file.
         * 
         * @return json object with format {
         *										"symbol":symbol,
         *										"baseQuantities":[base_quantity_1 ... base_quantity_N],
         *										"derivedQuantities":[derived_quantity_1 ... derived_quantity_N],
         *										"coherentUnits":[coherent_unit_1 ... coherent_unit_N],
         *										"nonCoherentUnits":[non_coherent_unit_1 ... non_coherent_unit_N]
         *									}
         */
        QJsonObject toJson() const;
        /**
         * Converts json object with same to 'toJson()' format back into 'UnitsSystem' class instance.
         * 
         * @param json object with format described in 'toJson()' method documentation
         * @return instance of 'UnitsSystem' with data from 'jsonObject'
         */
        static UnitsSystem fromJson(const QJsonObject& jsonObject);

        /**
         * Adds basis quantity and corresponding coherent unit to this unit system.
         * Adds quantity and unit to all searching maps and sets.
         * 
         * @param baseQuantitySymbol basis quantity symbol, should not be already added
         * @param baseCoherentUnitSymbol corresponding coherent unit symbol, should not be already added
         * @param baseQuantityTitle basis quantity title
         * @param baseCoherentUnitTitle corresponding coherent unit title
         */
        void addBaseUnit(QString baseQuantitySymbol, QString baseCoherentUnitSymbol, QString baseQuantityTitle, QString baseCoherentUnitTitle);
        /**
         * Adds derived quantity if not present already and corresponding unit.
         * Adds quantity and unit to all searching maps and sets.
         * 
         * @param quantitySymbol any quantity symbol
         * @param unitSymbol unit symbol
         * @param quantityTitle any quantity title
         * @param unitTitle unit title
         * @param convertionRatio unit convertionRatioFromBaseUnits
         * @param qunatityDimension quantity dimension
         */
        void addAdditionalUnits(QString quantitySymbol, QString unitSymbol, QString quantityTitle, QString unitTitle, qreal convertionRatio, Dimension qunatityDimension);
    };

    /**
     * Representing dimensional value.
     */
    struct Value
    {
        qreal value;
        const Unit& unit;
    };

    /**
     * Object for returning from manager to converting between units in units system.
     */
    class UnitsConverter
    {
        const UnitsSystem& c_unitsSystem; // Reference to units system stored in manager

    public:
        explicit UnitsConverter(const UnitsSystem& system);

        /**
         * Converts value to given unit using data from reference in value. Does not account to units system itself, only references to units instances.
         * 
         * @param inputValue dimensional value
         * @param outputUnit reference to unit
         * @return converted dimensional value in given unit
         */
        Value convert(const Value& inputValue, const Unit& outputUnit) const;
        /**
         * Converts value to coherent unit of corresponding quantity.
         * 
         * @param inputValue dimensional value
         * @return converted dimensional value in coherent unit of corresponding quantity
         */
        Value toCoherent(const Value& inputValue) const;
    };

    /**
     * Class responsible for writing and reading units systems from files and managing the folders structure (currently no structure to manage present).
     */
    class ConfigurationFileManager
    {
    public:
        /**
         * Initialization parameters for ConfigurationFileManager.
         */
        struct ConfigurationFileManagerParameters
        {
            QString folderPath;
            const QString extension = "json";
        };
    
    public:
        /**
         * Folder path and files extension should be provided in parameters.
         * 
         * @param parameters format: {folderPath : QString, extension : QString}
         */
        explicit ConfigurationFileManager(const ConfigurationFileManagerParameters& parameters);
        
        /**
         * Writes into file with name: '%system.symbol%.%parameters.extension%' into specified in parameters folder.
         * 
         * @param system symbol used for file name
         * @return true if successfully written
         */
        bool writeIntoFile(const UnitsSystem& system);
        /**
         * Reads units system by looking for file with name formed from given string.
         * 
         * @param unitsSystemSymbol used for file name
         * @return instance of UnitsSystem with data from file
         */
        UnitsSystem readFromFile(const QString& unitsSystemSymbol) const;
        /**
         * Returns list of symbols corresponding to found files names.
         * 
         * @param reload if false will not rescan directory and only return previously scanned list
         * @return list of system symbols for use in 'readFromFile' method
         */
        const QList<QString>& getUnitsSystemSymbols(bool reload = false);

    private:
        const ConfigurationFileManagerParameters c_parameters; // parameters for generating file path and name
        QList<QString> m_systemsSymbols; // earlier scanned symbols for avoid excess rescanning

        /**
         * Method to unify path generation algorithm.
         * 
         * @param unitsSystemSymbol
         * @param folderPath
         * @return path to units system file corresponding to 'unitsSystemSymbol'
         */
        QString toPath(const QString& unitsSystemSymbol, const QString& folderPath) const;
    };

    /**
     * Manager meant to be used for interacting with units systems.
     * Have Qt event handler functionality.
     */
    class MeasurementSystemManager : public QObject
    {
        Q_OBJECT

    public:
        /**
         * For initializing.
         */
        struct MeasurementSystemManagerParameters
        {
            QString configsFolderPath;
            QString defaultSystemSymbol;
        };

    private:
        MeasurementSystemManagerParameters m_parameters;
        ConfigurationFileManager m_configurationFileManager;
        UnitsSystem m_unitsSystem;

    public:
        /**
        * 'configsFolderPath' - path to folder with configuration files.
        * 'defaultSystemSymbol' - system symbol used to read from file on initialization.
        *
        * @param parameters format: {configsFolderPath : QString, defaultSystemSymbol : QString}
        */
        explicit MeasurementSystemManager(const MeasurementSystemManagerParameters& parameters);

        /**
         * Returns ref to unitsSystem for manual editing. Temporary.
         * @TODO Remove and refactor usage
         * 
         * @return ref to manager's units system
         */
        UnitsSystem& modifiableUnitsSystem();
        /**
         * Constant reference for getting data from system.
         * 
         * @param symbol
         * @param reload if true system will be read from file and stored in manager 
         * @return constant ref to manager's units system
         */
        const UnitsSystem& getUnitsSystem(QString symbol = "", bool reload = false);
        /**
         * List of systems in folder to be used in 'getUnitsSystem'.
         * 
         * @param reload if false stored value will be used
         * @return constant ref to list stored in configurationFileManager of this manager
         */
        const QList<QString>& getUnitsSystemsSymbols(bool reload = false);

        /**
         * Uses configurationFileManager to write stored unit system into file.
         * 
         * @return true if successful writed
         */
        bool writeToFile();
    };
}
